<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ralph Steadman-Style Interactive Icons</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        /* Define the color variables for the aesthetic */
        :root {
            --ink-black: #101010;
            --paper-white: #F0F0E0;
            --accent-red: #D00000;
            --secondary-blue: #0A6EAB;
        }

        body {
            background-color: var(--ink-black); 
            font-family: 'Inter', sans-serif;
            color: var(--paper-white);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            width: 100%;
            border: 2px solid var(--accent-red);
            box-shadow: 0 0 30px rgba(208, 0, 0, 0.6);
            border-radius: 12px;
            padding: 20px;
            background-color: #2a2a2a; /* Dark background for contrast */
        }

        canvas {
            display: block;
            margin: 0 auto;
            border-radius: 4px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            background-color: var(--paper-white);
        }

        h1 {
            color: var(--paper-white);
            text-shadow: 2px 2px 0 var(--accent-red);
        }

        /* Styling for the custom range inputs */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: #4a4a4a;
            border-radius: 3px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--accent-red);
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid var(--paper-white);
            box-shadow: 0 0 5px var(--accent-red);
        }

        /* Styling for the color input */
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            padding: 0;
            border: none;
            width: 100%;
            height: 40px;
            cursor: pointer;
            background: none;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
            border-radius: 6px;
        }
        input[type="color"]::-webkit-color-swatch {
            border: 2px solid var(--paper-white);
            border-radius: 6px;
        }
    </style>
</head>
<body>
    <div class="container text-center">
        <h1 class="text-3xl sm:text-4xl font-extrabold mb-4">Chaotic Data Icons (Steadman Style)</h1>
        <p class="text-sm text-gray-400 mb-6">Test the size and color to ensure visibility, then fine-tune chaos.</p>

        <!-- Controls Section --><div class="flex flex-col md:flex-row gap-4 p-4 mb-6 bg-gray-900 rounded-lg shadow-xl">
            <!-- Row 1 Controls --><div class="flex-1">
                <label for="mode-selector" class="block text-sm font-medium text-gray-300 mb-2">Icon Mode</label>
                <select id="mode-selector" class="w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white focus:ring-red-500 focus:border-red-500 transition duration-150 ease-in-out">
                    <option value="soundWave">1. Sound Wave</option>
                    <option value="infiniteLoop">2. Infinite Loop</option>
                    <option value="waveSlicing" selected>3. Wave Slicing</option>
                    <option value="clustering">4. Clustering</option>
                    <option value="neuralNet">5. Neural Net</option>
                    <option value="linkedList">6. Linked List / Queue</option>
                    <option value="binaryTree">7. Binary Tree / Taxonomy</option>
                    <option value="dataFunnel">8. Data Funnel / Transformation</option>
                    <option value="heatmap">9. Heatmap / Grid</option>
                    <option value="scatterPlot">10. Scatter Plot / Growth</option>
                    <option value="listItem">11. List of Items</option>
                    <option value="spectralAnalysis">12. Spectral Analysis</option>
                    <option value="signalDecomposition">13. Signal Decomposition</option>
                    <option value="spectralEffect">14. Spectral Effect</option>
                </select>
            </div>
            
            <div class="flex-1">
                <label for="icon-size-multiplier" class="block text-sm font-medium text-gray-300 mb-2 flex justify-between">
                    <span>Size Multiplier:</span>
                    <span id="size-value" class="font-semibold text-red-400">0.7x</span>
                </label>
                <input type="range" id="icon-size-multiplier" min="0.1" max="1.5" value="0.7" step="0.1" class="w-full">
            </div>

            <div class="flex-1">
                <label for="base-ink-color" class="block text-sm font-medium text-gray-300 mb-2">Base Ink Color</label>
                <input type="color" id="base-ink-color" value="#101010" class="w-full h-10 p-1 border border-gray-700 rounded-md bg-gray-700">
            </div>

        </div>

        <!-- Row 2 Controls (Jitter, Splatter, Speed) --><div class="flex flex-col md:flex-row gap-4 p-4 mb-6 bg-gray-900 rounded-lg shadow-xl">
            <!-- Jitter Amount --><div class="flex-1">
                <label for="jitter-amount" class="block text-sm font-medium text-gray-300 mb-2 flex justify-between">
                    <span>Line Jitter:</span>
                    <span id="jitter-value" class="font-semibold text-red-400">5.0</span>
                </label>
                <input type="range" id="jitter-amount" min="0" max="20" value="5" step="0.5" class="w-full">
            </div>

            <!-- Splatter Amount --><div class="flex-1">
                <label for="splatter-amount" class="block text-sm font-medium text-gray-300 mb-2 flex justify-between">
                    <span>Ink Splatter Radius:</span>
                    <span id="splatter-value" class="font-semibold text-red-400">10</span>
                </label>
                <input type="range" id="splatter-amount" min="0" max="50" value="10" step="1" class="w-full">
            </div>

            <!-- Animation Speed --><div class="flex-1">
                <label for="animation-speed" class="block text-sm font-medium text-gray-300 mb-2 flex justify-between">
                    <span>Animation Speed:</span>
                    <span id="speed-value" class="font-semibold text-red-400">30 FPS</span>
                </label>
                <input type="range" id="animation-speed" min="10" max="60" value="30" step="5" class="w-full">
            </div>
        </div>


        <div id="sketch-container" class="w-full aspect-video">
            <!-- p5.js canvas will be placed here --></div>
    </div>

    <script>
        const sketch = (p) => {
            let config = {
                mode: 'waveSlicing', // Set default mode to the modified one
                jitter: 5,
                splatterRadius: 10,
                speed: 30,
                iconSizeMultiplier: 0.7,
                baseInkColor: '#101010', // Default dark ink
            };

            let INK; // This will be set in setup and draw based on config.baseInkColor
            const ACCENT = p.color('#D00000'); // Red
            const PAPER = p.color('#F0F0E0');
            const SECONDARY = p.color('#0A6EAB'); // Blue

            // Get control elements
            const modeSelector = document.getElementById('mode-selector');
            const jitterInput = document.getElementById('jitter-amount');
            const splatterInput = document.getElementById('splatter-amount');
            const speedInput = document.getElementById('animation-speed');
            const sizeInput = document.getElementById('icon-size-multiplier');
            const colorInput = document.getElementById('base-ink-color');
            
            const jitterValueSpan = document.getElementById('jitter-value');
            const splatterValueSpan = document.getElementById('splatter-value');
            const speedValueSpan = document.getElementById('speed-value');
            const sizeValueSpan = document.getElementById('size-value');


            p.setup = () => {
                const container = document.getElementById('sketch-container');
                p.createCanvas(container.offsetWidth, container.offsetHeight).parent('sketch-container');
                p.angleMode(p.DEGREES);
                p.strokeCap(p.ROUND);
                p.frameRate(config.speed);
                INK = p.color(config.baseInkColor);
                window.addEventListener('resize', resizeCanvas);
                setupControls();
            };

            p.draw = () => {
                // Ensure INK color is updated every frame if the color input changes
                INK = p.color(config.baseInkColor);

                p.background(PAPER); 
                p.noFill();
                addPaperNoise(100); // Subtle background noise

                // Calculate SIZE dynamically based on the multiplier
                const SIZE = p.min(p.width, p.height) * config.iconSizeMultiplier;
                
                p.push();
                p.translate(p.width / 2, p.height / 2);
                
                // Draw based on the selected mode
                switch (config.mode) {
                    case 'soundWave':
                        drawJitteredSoundWave(SIZE);
                        break;
                    case 'infiniteLoop':
                        drawChaoticInfiniteLoop(SIZE);
                        break;
                    case 'waveSlicing':
                        drawSteadmanWaveSlicing(SIZE);
                        break;
                    case 'clustering':
                        drawSteadmanClustering(SIZE);
                        break;
                    case 'neuralNet':
                        drawSteadmanNeuralNet(SIZE);
                        break;
                    case 'linkedList':
                        drawSteadmanLinkedList(SIZE);
                        break;
                    case 'binaryTree':
                        drawSteadmanBinaryTree(SIZE);
                        break;
                    case 'dataFunnel':
                        drawSteadmanDataFunnel(SIZE);
                        break;
                    case 'heatmap':
                        drawSteadmanHeatmap(SIZE);
                        break;
                    case 'scatterPlot':
                        drawSteadmanScatterPlot(SIZE);
                        break;
                    case 'listItem':
                        drawSteadmanList(SIZE); // NEW
                        break;
                    case 'spectralAnalysis':
                        drawSteadmanSpectralAnalysis(SIZE); // NEW
                        break;
                    case 'signalDecomposition':
                        drawSteadmanSignalDecomposition(SIZE); // NEW
                        break;
                    case 'spectralEffect':
                        drawSteadmanSpectralEffect(SIZE); // NEW
                        break;
                }

                p.pop();
            };

            // --- p5.js/Canvas Event Handlers ---

            const resizeCanvas = () => {
                const container = document.getElementById('sketch-container');
                p.resizeCanvas(container.offsetWidth, container.offsetHeight);
            };
            
            // --- UI Control Setup ---

            function setupControls() {
                modeSelector.addEventListener('change', (e) => config.mode = e.target.value);
                
                jitterInput.addEventListener('input', (e) => {
                    config.jitter = parseFloat(e.target.value);
                    jitterValueSpan.textContent = config.jitter.toFixed(1);
                });

                splatterInput.addEventListener('input', (e) => {
                    config.splatterRadius = parseFloat(e.target.value);
                    splatterValueSpan.textContent = config.splatterRadius;
                });

                speedInput.addEventListener('input', (e) => {
                    config.speed = parseInt(e.target.value);
                    speedValueSpan.textContent = `${config.speed} FPS`;
                    p.frameRate(config.speed);
                });

                sizeInput.addEventListener('input', (e) => {
                    config.iconSizeMultiplier = parseFloat(e.target.value);
                    sizeValueSpan.textContent = `${config.iconSizeMultiplier.toFixed(1)}x`;
                });
                
                colorInput.addEventListener('input', (e) => {
                    config.baseInkColor = e.target.value;
                });
            }


            // --- STEADMAN AESTHETIC HELPERS ---

            /**
             * Sets a random, jagged stroke weight and color for a raw look.
             */
            function _steadmanStroke(color = INK, baseWeight = 2) {
                p.stroke(color);
                // Randomly vary the stroke weight slightly to simulate pen pressure changes
                p.strokeWeight(baseWeight + p.random(-0.5, 1.5));
            }
            
            /**
             * Draws a cluster of randomized dots and ellipses to simulate an ink splatter/drip.
             */
            function _drawSplatter(cx, cy, baseRadius, color = INK) {
                if (config.splatterRadius === 0) return;

                p.push();
                p.noStroke();
                p.fill(color);

                const finalRadius = baseRadius + config.splatterRadius * 0.2;
                const numBlobs = p.floor(p.random(5, 10 + config.splatterRadius / 5));

                for (let i = 0; i < numBlobs; i++) {
                    // Random angle and distance for placement
                    const angle = p.random(360);
                    const r = p.random(baseRadius * 0.5, finalRadius);
                    
                    const x = cx + r * p.cos(angle);
                    const y = cy + r * p.sin(angle);
                    
                    // Blob size
                    const size = p.random(1, 4) * p.map(r, 0, finalRadius, 1.5, 0.5); 
                    
                    p.ellipse(x, y, size, size);
                }
                p.pop();
            }

            /**
             * Adds randomized points to the background to simulate textured paper.
             */
            function addPaperNoise(density) {
                p.push();
                p.stroke(INK);
                p.strokeWeight(1);
                
                for (let i = 0; i < density; i++) {
                    // Use a low alpha for the noise points
                    p.stroke(p.color(p.red(INK), p.green(INK), p.blue(INK), 50)); 
                    p.point(p.random(p.width), p.random(p.height));
                }
                p.pop();
            }

            /**
             * Draws a chaotic, wobbly node (circle) suitable for trees, queues, etc.
             */
            function _drawWobblyNode(x, y, radius, color = INK) {
                p.push();
                p.translate(x, y);

                // Draw outer chaotic boundary
                _steadmanStroke(color, 3);
                p.noFill();
                
                p.beginShape();
                const nodeJitter = config.jitter * 0.5;
                const totalPoints = 30;
                
                // Add rotation based on frameCount for gentle animation
                const rotation = p.frameCount * 0.5; 
                
                for(let a = 0; a < 360; a += 360/totalPoints) {
                    const r = radius + p.random(-nodeJitter, nodeJitter);
                    p.vertex(r * p.cos(a + rotation), r * p.sin(a + rotation));
                }
                p.endShape(p.CLOSE);

                // Add inner ink spot
                p.noStroke();
                p.fill(color);
                p.ellipse(p.random(-1, 1), p.random(-1, 1), radius * 0.5, radius * 0.5);
                
                // Splatter at the node center
                _drawSplatter(0, 0, config.splatterRadius * 0.5, color);

                p.pop();
            }

            /**
             * Draws a chaotic, hand-drawn arrow line.
             */
            function _drawChaoticArrow(x1, y1, x2, y2, color = INK) {
                p.push();
                _steadmanStroke(color, 2);
                p.line(x1, y1, x2, y2);
                
                // Draw arrowhead (chaotic triangle)
                const angle = p.atan2(y2 - y1, x2 - x1);
                const arrowSize = 10;
                p.translate(x2, y2);
                p.rotate(angle);
                
                p.line(0, 0, -arrowSize + p.random(-2, 2), -arrowSize/2 + p.random(-2, 2));
                p.line(0, 0, -arrowSize + p.random(-2, 2), arrowSize/2 + p.random(-2, 2));
                
                p.pop();
            }

            /**
             * Draws a stylized, chaotic processor box.
             */
            function _drawProcessorBox(x, y, boxW, boxH, color = INK) {
                p.push();
                p.translate(x, y);

                _steadmanStroke(color, 4);
                p.fill(p.color(color, 20)); // Slightly transparent fill

                const j = config.jitter * 0.5; // More jitter for the box itself

                // Draw chaotic main shape
                p.beginShape();
                p.vertex(0 + p.random(-j, j), 0 + p.random(-j, j));
                p.vertex(boxW + p.random(-j, j), 0 + p.random(-j, j));
                p.vertex(boxW + p.random(-j, j), boxH + p.random(-j, j));
                p.vertex(0 + p.random(-j, j), boxH + p.random(-j, j));
                p.endShape(p.CLOSE);

                // Add internal chaotic lines/circuits
                _steadmanStroke(p.color(color, 150), 1);
                p.line(boxW * 0.2 + p.random(-j,j), boxH * 0.2 + p.random(-j,j), boxW * 0.8 + p.random(-j,j), boxH * 0.4 + p.random(-j,j));
                p.line(boxW * 0.2 + p.random(-j,j), boxH * 0.8 + p.random(-j,j), boxW * 0.6 + p.random(-j,j), boxH * 0.2 + p.random(-j,j));
                p.line(boxW * 0.5 + p.random(-j,j), boxH * 0.1 + p.random(-j,j), boxW * 0.5 + p.random(-j,j), boxH * 0.9 + p.random(-j,j));

                // Add chaotic internal splatters/nodes
                p.noStroke();
                p.fill(ACCENT, 100);
                p.ellipse(boxW * 0.3 + p.random(-2,2), boxH * 0.7 + p.random(-2,2), 5, 5);
                p.ellipse(boxW * 0.7 + p.random(-2,2), boxH * 0.3 + p.random(-2,2), 5, 5);

                // Add some chaotic drips/spikes on the sides
                if (p.frameCount % 5 === 0) {
                    _steadmanStroke(color, 2);
                    p.line(boxW, boxH * p.random(0.1, 0.9), boxW + p.random(5,10), boxH * p.random(0.1, 0.9));
                    p.line(0, boxH * p.random(0.1, 0.9), p.random(-5,-10), boxH * p.random(0.1, 0.9));
                }

                p.pop();
            }

            // --- ICON DRAWING FUNCTIONS ---
            
            // 1. Sound Wave (Sine Wave)
            function drawJitteredSoundWave(SIZE) {
                const W = SIZE * 0.8;
                const H = SIZE * 0.5;
                const frame = p.frameCount;
                
                p.push();
                p.translate(-W / 2, 0); 
                _steadmanStroke(INK, 3);

                // Draw the central, chaotic wave using stable line segments
                let prevX = 0;
                let prevY = 0;
                for (let x = 5; x <= W; x += 5) {
                    let y = p.sin(p.map(x, 0, W, 0, 720) + frame * 3) * H * 0.4;
                    
                    // Add significant Steadman-esque noise 
                    let noiseFactor = p.noise(x * 0.05, frame * 0.08) * 15 - 7.5; 
                    y += noiseFactor;

                    const currentX = x + p.random(-config.jitter, config.jitter) * 0.3;
                    const currentY = y + p.random(-config.jitter, config.jitter) * 0.3;
                    
                    // Draw the line segment
                    p.line(prevX, prevY, currentX, currentY);

                    prevX = currentX;
                    prevY = currentY;
                }
                
                // Add an "Explosion" point at the end (Accent Red)
                const endX = prevX;
                const endY = prevY;
                
                p.stroke(ACCENT);
                p.strokeWeight(4);
                p.line(endX, endY, endX + W * 0.1, endY - H * 0.2);
                _drawSplatter(endX + W * 0.1, endY - H * 0.2, 15, ACCENT);
                
                // Add a few drips along the path
                if (p.frameCount % 20 === 0) {
                    const dripX = p.random(W * 0.1, W * 0.9);
                    const dripY = p.sin(p.map(dripX, 0, W, 0, 720) + frame * 3) * H * 0.4;
                    _drawSplatter(dripX, dripY, 5, INK);
                }

                p.pop();
            }

            // 2. Chaotic Figure-Eight (Infinite Loop)
            function drawChaoticInfiniteLoop(SIZE) {
                const R = SIZE * 0.35; 
                const frame = p.frameCount;
                
                p.push();
                _steadmanStroke(INK, 4);
                p.noFill();

                let prevX = R; 
                let prevY = 0;
                
                // Draw the core chaotic path using stable line segments
                for (let angle = 5; angle <= 360; angle += 5) {
                    const r_squared = 2 * R * R * p.cos(2 * angle);
                    
                    if (r_squared >= 0) {
                        const r = p.sqrt(r_squared);
                        let x = r * p.cos(angle);
                        let y = r * p.sin(angle);
                        
                        // Apply Jitter
                        const currentX = x + p.random(-config.jitter, config.jitter);
                        const currentY = y + p.random(-config.jitter, config.jitter);
                        
                        p.line(prevX, prevY, currentX, currentY);

                        prevX = currentX;
                        prevY = currentY;
                    }
                }
                
                // Animated Ink Blob (accentuating the 'flow')
                const t = (frame * 3) % 360; 
                const r_squared_t = 2 * R * R * p.cos(2 * t);

                if (r_squared_t >= 0) {
                    const r_t = p.sqrt(r_squared_t);
                    const particleX = r_t * p.cos(t);
                    const particleY = r_t * p.sin(t);
                    
                    p.noStroke();
                    p.fill(ACCENT);
                    p.ellipse(particleX, particleY, 8 + p.random(-1, 3), 8 + p.random(-1, 3));
                    _drawSplatter(particleX, particleY, config.splatterRadius, ACCENT);
                }

                p.pop();
            }

            // 3. Wave Slicing
            function drawSteadmanWaveSlicing(SIZE) {
                const W = SIZE * 0.8;
                const H = SIZE * 0.7;
                const sliceCount = 10; 
                const frame = p.frameCount;
                const noiseScale = 0.05; 
                const noiseOffset = frame * 0.01; 

                p.push();
                p.translate(-W / 2, -H / 2);

                // 1. Draw the Complex Sound Waveform
                let mainPrevX = 0;
                let mainPrevY = H / 2;

                _steadmanStroke(INK, 5); 
                
                for (let x = 5; x <= W; x += 5) {
                    let noiseVal = p.noise(x * noiseScale, noiseOffset);
                    let y = p.map(noiseVal, 0, 1, H * 0.1, H * 0.9);
                    
                    let jitterY = y + p.random(-config.jitter, config.jitter) * 0.5;

                    const currentX = x + p.random(-config.jitter, config.jitter) * 0.5;
                    
                    p.line(mainPrevX, mainPrevY, currentX, jitterY);

                    mainPrevX = currentX;
                    mainPrevY = jitterY;
                }
                
                // 2. Draw Vertical Slicing Lines
                for (let i = 0; i < sliceCount; i++) { // Changed to < sliceCount to avoid drawing a line at W for consistency
                    const sliceX = W * (i / sliceCount);
                    
                    const currentSliceX = sliceX + p.random(-config.jitter, config.jitter) * 0.5;
                    
                    _steadmanStroke(SECONDARY, 2); 
                    
                    p.push();
                    p.line(currentSliceX, 0, currentSliceX, H); 
                    
                    // 3. Draw Intersection Point Splatter
                    let waveNoiseVal = p.noise(sliceX * noiseScale, noiseOffset);
                    let waveY = p.map(waveNoiseVal, 0, 1, H * 0.1, H * 0.9);
                    
                    const intersectionY = waveY + p.random(-config.jitter, config.jitter) * 0.5;
                    
                    _drawSplatter(currentSliceX, intersectionY, 10, ACCENT);
                    p.pop();
                }

                p.pop();
            }

            // 4. Clustering (Simplified K-Means)
            function drawSteadmanClustering(SIZE) {
                const R = SIZE * 0.4;
                const frame = p.frameCount;
                const pointCount = 50;
                const clusterCenters = 4;

                const colors = [ACCENT, SECONDARY, p.color('#FDBA74'), p.color('#84CC16')]; 

                // Define chaotic, jittered centers
                const centers = [];
                for (let i = 0; i < clusterCenters; i++) {
                    const angle = i * 360 / clusterCenters + frame * 0.1;
                    centers.push({
                        x: p.cos(angle) * R * 0.5,
                        y: p.sin(angle) * R * 0.5,
                        color: colors[i]
                    });
                }
                
                // Draw points and their connections
                for (let i = 0; i < pointCount; i++) {
                    const centerIndex = i % clusterCenters;
                    const center = centers[centerIndex];
                    
                    const px = center.x + p.cos(i * 10 + frame) * R * 0.15 * p.random(0.5, 1.5);
                    const py = center.y + p.sin(i * 10 + frame) * R * 0.15 * p.random(0.5, 1.5);

                    // Draw connection line
                    p.push();
                    _steadmanStroke(center.color, 1);
                    p.line(px + p.random(-config.jitter, config.jitter) * 0.2, 
                           py + p.random(-config.jitter, config.jitter) * 0.2, 
                           center.x + p.random(-config.jitter, config.jitter) * 0.2, 
                           center.y + p.random(-config.jitter, config.jitter) * 0.2);
                    p.pop();

                    // Draw the point as a messy ink blob
                    p.push();
                    p.noStroke();
                    p.fill(center.color);
                    p.ellipse(px + p.random(-1, 1), py + p.random(-1, 1), 5 + p.random(-1, 1), 5 + p.random(-1, 1));
                    _drawSplatter(px, py, config.splatterRadius * 0.5, center.color);
                    p.pop();
                }

                // Draw the chaotic centers (Centroids)
                centers.forEach(c => {
                    p.push();
                    _steadmanStroke(INK, 5);
                    p.noFill();
                    p.line(c.x - 10, c.y - 10, c.x + 10, c.y + 10);
                    p.line(c.x - 10, c.y + 10, c.x + 10, c.y - 10);
                    _drawSplatter(c.x, c.y, config.splatterRadius, INK);
                    p.pop();
                });
            }

            // 5. Neural Net Flow
            function drawSteadmanNeuralNet(SIZE) {
                const layers = [4, 6, 6, 3]; 
                const W = SIZE * 0.9;
                const H = SIZE * 0.8;
                const frame = p.frameCount;

                const layerSpacing = W / (layers.length - 1);
                const flowProgress = (frame * 5) % 1000 / 1000; 

                p.push();
                p.translate(-W / 2, -H / 2);

                // 1. Draw Connections (Weights) as chaotic lines
                for (let l = 0; l < layers.length - 1; l++) {
                    const x1 = l * layerSpacing;
                    const x2 = (l + 1) * layerSpacing;

                    for (let i = 0; i < layers[l]; i++) {
                        const y1 = H * (i + 1) / (layers[l] + 1);
                        
                        for (let j = 0; j < layers[l + 1]; j++) {
                            const y2 = H * (j + 1) / (layers[l + 1] + 1);
                            
                            // Draw base chaotic line
                            p.push();
                            _steadmanStroke(SECONDARY, 1.5); 
                            
                            const jx1 = x1 + p.random(-config.jitter, config.jitter) * 0.2;
                            const jy1 = y1 + p.random(-config.jitter, config.jitter) * 0.2;
                            const jx2 = x2 + p.random(-config.jitter, config.jitter) * 0.2;
                            const jy2 = y2 + p.random(-config.jitter, config.jitter) * 0.2;
                            
                            p.line(jx1, jy1, jx2, jy2);
                            p.pop();

                            // Draw animated ink flow
                            const tx = p.lerp(x1, x2, flowProgress);
                            const ty = p.lerp(y1, y2, flowProgress);

                            p.noStroke();
                            p.fill(ACCENT);
                            p.ellipse(tx, ty, 4, 4);
                            
                            if (p.random() < 0.05) {
                                _drawSplatter(tx, ty, 5, ACCENT);
                            }
                        }
                    }
                }

                // 2. Draw Nodes (Neurons)
                for (let l = 0; l < layers.length; l++) {
                    const x = l * layerSpacing;

                    for (let i = 0; i < layers[l]; i++) {
                        const y = H * (i + 1) / (layers[l] + 1);
                        _drawWobblyNode(x, y, 15, INK);
                    }
                }

                p.pop();
            }

            // 6. Linked List / Queue
            function drawSteadmanLinkedList(SIZE) {
                const nodeCount = 5;
                const nodeRadius = 20;
                const spacing = SIZE * 0.15;
                const totalWidth = nodeCount * nodeRadius * 2 + (nodeCount - 1) * spacing;
                const frame = p.frameCount;
                
                p.push();
                p.translate(-totalWidth / 2, 0);

                const nodes = [];
                for (let i = 0; i < nodeCount; i++) {
                    const x = i * (nodeRadius * 2 + spacing) + nodeRadius;
                    const y = p.random(-config.jitter * 0.5, config.jitter * 0.5); // Vertical chaos
                    nodes.push({ x, y });
                }

                // 1. Draw Links (Pointers)
                for (let i = 0; i < nodeCount - 1; i++) {
                    const n1 = nodes[i];
                    const n2 = nodes[i + 1];
                    
                    // Jittered line connecting the centers
                    _steadmanStroke(SECONDARY, 2);
                    const j1x = n1.x + nodeRadius;
                    const j1y = n1.y + p.random(-config.jitter, config.jitter) * 0.2;
                    const j2x = n2.x - nodeRadius;
                    const j2y = n2.y + p.random(-config.jitter, config.jitter) * 0.2;

                    p.line(j1x, j1y, j2x, j2y);

                    // Animated flow marker (Queue/FIFO visualization)
                    const flowT = (frame * 5) % ((n2.x - n1.x) * 2);
                    const flowX = n1.x + nodeRadius + (flowT % (n2.x - n1.x - nodeRadius * 2));
                    if (flowX < n2.x - nodeRadius) {
                         p.fill(ACCENT);
                         p.noStroke();
                         p.ellipse(flowX, p.lerp(n1.y, n2.y, (flowX - n1.x - nodeRadius) / (n2.x - n1.x - nodeRadius * 2)), 6, 6);
                    }
                }

                // 2. Draw Nodes
                nodes.forEach((n, i) => {
                    _drawWobblyNode(n.x, n.y, nodeRadius, INK);
                    
                    // Add index/data inside node
                    p.fill(INK);
                    p.textSize(12);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.text(i + 1, n.x + p.random(-1, 1), n.y + p.random(-1, 1));
                });
                
                p.pop();
            }

            // 7. Binary Tree / Taxonomy
            function drawSteadmanBinaryTree(SIZE) {
                const W = SIZE * 0.8;
                const H = SIZE * 0.8;
                const nodeRadius = 15;
                const frame = p.frameCount;

                p.push();
                p.translate(-W / 2, -H / 2 + nodeRadius); // Start near the top

                function drawNodeAndChildren(x, y, level, maxLevel) {
                    if (level > maxLevel) return;

                    // Draw the current node
                    _drawWobblyNode(x, y, nodeRadius, INK);

                    // Draw the animated 'root' node differently
                    if (level === 0) {
                        _drawSplatter(x, y, 15, ACCENT);
                    }
                    
                    const nextLevel = level + 1;
                    const y_child = y + H / (maxLevel + 1);
                    const x_offset = W / (2 ** nextLevel) * 0.8;
                    
                    // Draw Left Child
                    if (level < maxLevel) {
                        const x_left = x - x_offset + p.sin(frame * 0.5) * 5;
                        
                        // Draw connection
                        _steadmanStroke(SECONDARY, 2);
                        p.line(x, y + nodeRadius, x_left + p.random(-config.jitter, config.jitter) * 0.2, y_child - nodeRadius + p.random(-config.jitter, config.jitter) * 0.2);
                        
                        drawNodeAndChildren(x_left, y_child, nextLevel, maxLevel);
                    }

                    // Draw Right Child
                    if (level < maxLevel && p.random() > 0.1) { // Chaotically omit some right branches
                        const x_right = x + x_offset + p.cos(frame * 0.5) * 5;

                        // Draw connection
                        _steadmanStroke(SECONDARY, 2);
                        p.line(x, y + nodeRadius, x_right + p.random(-config.jitter, config.jitter) * 0.2, y_child - nodeRadius + p.random(-config.jitter, config.jitter) * 0.2);
                        
                        drawNodeAndChildren(x_right, y_child, nextLevel, maxLevel);
                    }
                }

                drawNodeAndChildren(W / 2, 0, 0, 3); // Root node at 3 levels deep

                p.pop();
            }

            // 8. Data Funnel / Transformation
            function drawSteadmanDataFunnel(SIZE) {
                const W_top = SIZE * 0.7;
                const W_bottom = SIZE * 0.2;
                const H = SIZE * 0.8;
                const frame = p.frameCount;

                p.push();
                p.translate(-W_top / 2, -H / 2);

                // 1. Draw the Funnel Body
                _steadmanStroke(INK, 5);
                p.fill(p.color(INK, 10)); // Slightly transparent fill
                
                p.beginShape();
                p.vertex(0 + p.random(-config.jitter, config.jitter) * 0.5, 0 + p.random(-config.jitter, config.jitter) * 0.5); // Top Left
                p.vertex(W_top + p.random(-config.jitter, config.jitter) * 0.5, 0 + p.random(-config.jitter, config.jitter) * 0.5); // Top Right
                p.vertex(W_top/2 + W_bottom/2 + p.random(-config.jitter, config.jitter) * 0.5, H + p.random(-config.jitter, config.jitter) * 0.5); // Bottom Right
                p.vertex(W_top/2 - W_bottom/2 + p.random(-config.jitter, config.jitter) * 0.5, H + p.random(-config.jitter, config.jitter) * 0.5); // Bottom Left
                p.endShape(p.CLOSE);

                // 2. Draw Data Flow (Ink Drops)
                const dropCount = 10;
                for (let i = 0; i < dropCount; i++) {
                    const t = (frame * 5 + i * 50) % 1000 / 1000;
                    
                    const topX = p.lerp(0, W_top, i / dropCount);
                    const bottomX = p.lerp(W_top/2 - W_bottom/2, W_top/2 + W_bottom/2, i / dropCount);

                    const currentX = p.lerp(topX, bottomX, t);
                    const currentY = p.lerp(0, H, t);

                    // Add chaotic element
                    const chaosFactor = p.sin(frame * 2 + i * 10) * 10;
                    
                    p.fill(ACCENT);
                    p.noStroke();
                    p.ellipse(currentX + chaosFactor * t * 0.05, currentY, 8, 8);
                }

                // 3. Draw Output Splatter
                _drawSplatter(W_top/2, H + 20, 15, INK);

                p.pop();
            }

            // 9. Heatmap / Grid
            function drawSteadmanHeatmap(SIZE) {
                const W = SIZE * 0.8;
                const H = SIZE * 0.8;
                const rows = 8;
                const cols = 8;
                const cellW = W / cols;
                const cellH = H / rows;
                const frame = p.frameCount;

                p.push();
                p.translate(-W / 2, -H / 2);

                const baseColor = p.color(INK);
                const maxColor = p.color(ACCENT);

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const x = c * cellW;
                        const y = r * cellH;

                        // Noise value for heat/intensity
                        const noiseVal = p.noise(c * 0.2 + frame * 0.01, r * 0.2);
                        const intensity = p.map(noiseVal, 0, 1, 0.1, 1);
                        
                        // Chaotic color blending between base and max color
                        const cellColor = p.lerpColor(baseColor, maxColor, intensity);
                        p.fill(cellColor);
                        p.noStroke();

                        // Draw chaotic rectangle
                        const j = config.jitter * 0.2;
                        p.beginShape();
                        p.vertex(x + p.random(-j, j), y + p.random(-j, j));
                        p.vertex(x + cellW + p.random(-j, j), y + p.random(-j, j));
                        p.vertex(x + cellW + p.random(-j, j), y + cellH + p.random(-j, j));
                        p.vertex(x + p.random(-j, j), y + cellH + p.random(-j, j));
                        p.endShape(p.CLOSE);

                        // Overlay jagged grid lines
                        _steadmanStroke(INK, 1);
                        p.rect(x, y, cellW, cellH);

                        // Add small accent splatter on high intensity cells
                        if (intensity > 0.8 && config.splatterRadius > 0) {
                            p.fill(ACCENT, 150);
                            p.ellipse(x + cellW / 2, y + cellH / 2, 5, 5);
                        }
                    }
                }

                p.pop();
            }

            // 10. Scatter Plot / Growth
            function drawSteadmanScatterPlot(SIZE) {
                const W = SIZE * 0.8;
                const H = SIZE * 0.8;
                const pointCount = 50;
                const frame = p.frameCount;

                p.push();
                p.translate(-W / 2, -H / 2);

                // 1. Draw Axes
                _steadmanStroke(INK, 4);
                p.line(0, H, W, H); // X-axis (base)
                p.line(0, H, 0, 0); // Y-axis (growth)

                // 2. Draw Chaotic Growth Line
                _steadmanStroke(SECONDARY, 3);
                let growthPrevX = 0;
                let growthPrevY = H;
                for (let x = 0; x <= W; x += 20) {
                    // Simulating chaotic growth (noise influenced sine/curve)
                    let y = H * 0.5 - p.sin(p.map(x, 0, W, 0, 180) + frame * 0.5) * H * 0.45;
                    y += p.noise(x * 0.05, frame * 0.02) * 20 - 10;
                    y = p.constrain(y, 0, H);

                    const currentX = x + p.random(-config.jitter, config.jitter) * 0.2;
                    const currentY = y + p.random(-config.jitter, config.jitter) * 0.2;

                    p.line(growthPrevX, growthPrevY, currentX, currentY);
                    growthPrevX = currentX;
                    growthPrevY = currentY;
                }

                // 3. Draw Scatter Points
                for (let i = 0; i < pointCount; i++) {
                    const x = p.random(W);
                    const y = p.random(H);
                    
                    // Point coloring based on height (value)
                    const pointColor = p.lerpColor(p.color(SECONDARY), ACCENT, 1 - y / H);

                    p.push();
                    p.translate(x, y);
                    
                    p.noStroke();
                    p.fill(pointColor);
                    
                    // Draw a messy dot
                    p.ellipse(p.random(-1, 1), p.random(-1, 1), 6 + p.random(-2, 2), 6 + p.random(-2, 2));

                    // Add a thin, chaotic projection line to the x-axis
                    _steadmanStroke(p.color(INK, 100), 1);
                    p.line(0, 0, 0, H - y);
                    
                    p.pop();
                }

                p.pop();
            }

            // 11. List of Items (Vertical Wobbly Nodes)
            function drawSteadmanList(SIZE) {
                const nodeCount = 4;
                const nodeRadius = 25;
                const spacing = SIZE * 0.1;
                const totalHeight = nodeCount * nodeRadius * 2 + (nodeCount - 1) * spacing;
                
                p.push();
                p.translate(0, -totalHeight / 2 + nodeRadius);

                const x = p.random(-config.jitter * 0.5, config.jitter * 0.5); // Horizontal chaos
                
                for (let i = 0; i < nodeCount; i++) {
                    const y = i * (nodeRadius * 2 + spacing);
                    
                    // Draw the wobbly node
                    _drawWobblyNode(x, y, nodeRadius, INK);

                    // Add a chaotic check mark or marker
                    p.push();
                    p.translate(x + nodeRadius * 0.8, y - nodeRadius * 0.8);
                    _steadmanStroke(ACCENT, 3);
                    p.line(0, 0, 5 + p.random(-2, 2), 10 + p.random(-2, 2));
                    p.line(5, 10, 15 + p.random(-2, 2), 0 + p.random(-2, 2));
                    p.pop();

                    // Draw connecting line/path (if not the last one)
                    if (i < nodeCount - 1) {
                        _steadmanStroke(SECONDARY, 1.5);
                        p.line(x, y + nodeRadius, x + p.random(-config.jitter*0.2, config.jitter*0.2), y + nodeRadius + spacing);
                    }
                }
                
                p.pop();
            }

            // 12. Spectral Analysis (Wave to Bars)
            function drawSteadmanSpectralAnalysis(SIZE) {
                const W = SIZE * 0.9;
                const H = SIZE * 0.8;
                const frame = p.frameCount;
                const barCount = 15;
                const boxW = W * 0.3;
                
                p.push();
                p.translate(-W / 2, -H / 2);

                const centerLineY = H * 0.6;
                
                // 1. Draw Chaotic Input Wave
                let prevX = 0;
                let prevY = H * 0.4;
                _steadmanStroke(SECONDARY, 3);
                for (let x = 5; x <= W * 0.3; x += 5) {
                    let y = H * 0.4 + p.sin(p.map(x, 0, W * 0.3, 0, 720) + frame * 4) * H * 0.15;
                    y += p.noise(x * 0.1, frame * 0.1) * 10 - 5;
                    
                    const currentX = x + p.random(-config.jitter, config.jitter) * 0.2;
                    const currentY = y + p.random(-config.jitter, config.jitter) * 0.2;
                    
                    p.line(prevX, prevY, currentX, currentY);
                    prevX = currentX;
                    prevY = currentY;
                }
                
                // 2. Draw Transformation Box (Processor style)
                const boxX = W * 0.35;
                const boxH = H * 0.5;
                const boxY = H * 0.25;
                _drawProcessorBox(boxX, boxY, boxW, boxH, INK);
                
                // 3. Draw Output Spectrum (Bars)
                const specXStart = W * 0.75;
                const specW = W * 0.2;
                const barW = specW / barCount;
                
                _steadmanStroke(INK, 2);
                p.line(specXStart, centerLineY, specXStart + specW, centerLineY); // Base Axis

                for (let i = 0; i < barCount; i++) {
                    const barX = specXStart + i * barW;
                    const noiseVal = p.noise(i * 0.3, frame * 0.1);
                    const barH = p.map(noiseVal, 0, 1, H * 0.05, H * 0.4);
                    
                    // Draw the chaotic bar
                    p.fill(p.lerpColor(SECONDARY, ACCENT, noiseVal));
                    const j = config.jitter * 0.2;
                    p.rect(barX + p.random(-j, j), centerLineY - barH + p.random(-j, j), 
                           barW * 0.7, barH + p.random(-j, j));
                    
                    // Add spike/splatter on top
                    if (barH > H * 0.3) {
                        _drawSplatter(barX + barW/2, centerLineY - barH, config.splatterRadius * 0.5, ACCENT);
                    }
                }

                // 4. Draw Input/Output Arrows
                _drawChaoticArrow(W * 0.3, H * 0.4, boxX, H * 0.4, INK);
                _drawChaoticArrow(boxX + boxW, centerLineY, specXStart, centerLineY, INK);

                p.pop();
            }

            // 13. Signal Decomposition
            function drawSteadmanSignalDecomposition(SIZE) {
                const W = SIZE * 0.9;
                const H = SIZE * 0.8;
                const frame = p.frameCount;
                const boxW = W * 0.2;
                
                p.push();
                p.translate(-W / 2, -H / 2);

                const inputY = H * 0.5;
                const outputY1 = H * 0.25;
                const outputY2 = H * 0.75;

                // 1. Draw Input Triangle Wave
                _steadmanStroke(SECONDARY, 3);
                let prevX = 0;
                let prevY = inputY;
                for (let x = 0; x <= W * 0.3; x += 5) {
                    const period = W * 0.15;
                    const triPhase = (x % period) / period;
                    let y;
                    if (triPhase < 0.5) {
                        y = inputY - H * 0.15 * p.map(triPhase, 0, 0.5, 0, 1);
                    } else {
                        y = inputY - H * 0.15 * p.map(triPhase, 0.5, 1, 1, 0);
                    }
                    y += p.noise(x * 0.1, frame * 0.05) * 5 - 2.5; // Chaos
                    
                    p.line(prevX, prevY, x + p.random(-config.jitter*0.1, config.jitter*0.1), y + p.random(-config.jitter*0.1, config.jitter*0.1));
                    prevX = x;
                    prevY = y;
                }
                
                // 2. Draw Decomposition Box (Processor style)
                const boxX = W * 0.4;
                const boxH = H * 0.3;
                _drawProcessorBox(boxX, H * 0.35, boxW, boxH, INK);

                // 3. Draw Output Sine Waves (Low and High Frequency)
                const outXStart = W * 0.7;
                const outW = W * 0.3;
                
                // Low Freq (Output 1)
                _steadmanStroke(ACCENT, 3);
                prevX = outXStart; prevY = outputY1;
                for (let x = 0; x <= outW; x += 5) {
                    let y = outputY1 + p.sin(p.map(x, 0, outW, 0, 360) + frame * 2) * H * 0.1;
                    y += p.noise(x * 0.05, frame * 0.1) * 3 - 1.5;
                    p.line(prevX, prevY, outXStart + x + p.random(-config.jitter*0.1, config.jitter*0.1), y + p.random(-config.jitter*0.1, config.jitter*0.1));
                    prevX = outXStart + x;
                    prevY = y;
                }

                // High Freq (Output 2)
                _steadmanStroke(SECONDARY, 2);
                prevX = outXStart; prevY = outputY2;
                for (let x = 0; x <= outW; x += 5) {
                    let y = outputY2 + p.sin(p.map(x, 0, outW, 0, 1080) + frame * 5) * H * 0.05;
                    y += p.noise(x * 0.1, frame * 0.1) * 5 - 2.5;
                    p.line(prevX, prevY, outXStart + x + p.random(-config.jitter*0.1, config.jitter*0.1), y + p.random(-config.jitter*0.1, config.jitter*0.1));
                    prevX = outXStart + x;
                    prevY = y;
                }
                
                // 4. Draw Arrows
                _drawChaoticArrow(W * 0.3, inputY, boxX, inputY, INK);
                _drawChaoticArrow(boxX + boxW, inputY, outXStart, outputY1, INK);
                _drawChaoticArrow(boxX + boxW, inputY, outXStart, outputY2, INK);
                
                p.pop();
            }

            // 14. Spectral Effect (Signal to Sparkles)
            function drawSteadmanSpectralEffect(SIZE) {
                const W = SIZE * 0.9;
                const H = SIZE * 0.8;
                const frame = p.frameCount;
                const boxW = W * 0.2;
                
                p.push();
                p.translate(-W / 2, -H / 2);

                const inputY = H * 0.5;

                // 1. Draw Input Sine Wave
                _steadmanStroke(SECONDARY, 3);
                let prevX = 0;
                let prevY = inputY;
                for (let x = 0; x <= W * 0.3; x += 5) {
                    let y = inputY + p.sin(p.map(x, 0, W * 0.3, 0, 720) + frame * 4) * H * 0.15;
                    y += p.noise(x * 0.1, frame * 0.1) * 10 - 5;
                    
                    const currentX = x + p.random(-config.jitter, config.jitter) * 0.2;
                    const currentY = y + p.random(-config.jitter, config.jitter) * 0.2;
                    
                    p.line(prevX, prevY, currentX, currentY);
                    prevX = currentX;
                    prevY = currentY;
                }
                
                // 2. Draw Effect Box (Processor style)
                const boxX = W * 0.4;
                const boxH = H * 0.3;
                _drawProcessorBox(boxX, H * 0.35, boxW, boxH, INK);

                // 3. Draw Output Wave with Heavy Splatter
                const outXStart = W * 0.7;
                const outW = W * 0.3;
                
                _steadmanStroke(ACCENT, 4);
                prevX = outXStart; prevY = inputY;
                for (let x = 0; x <= outW; x += 5) {
                    let y = inputY + p.sin(p.map(x, 0, outW, 0, 360) + frame * 3) * H * 0.2; // Amplified
                    y += p.noise(x * 0.1, frame * 0.05) * 15 - 7.5; // More chaos
                    
                    const currentX = outXStart + x + p.random(-config.jitter*0.3, config.jitter*0.3);
                    const currentY = y + p.random(-config.jitter*0.3, config.jitter*0.3);

                    p.line(prevX, prevY, currentX, currentY);
                    prevX = currentX;
                    prevY = currentY;
                    
                    // Add massive splatter along the path
                    if (p.random() < 0.25) {
                        _drawSplatter(currentX, currentY, config.splatterRadius * 1.5, ACCENT);
                    }
                }
                
                // 4. Draw Arrows
                _drawChaoticArrow(W * 0.3, inputY, boxX, inputY, INK);
                _drawChaoticArrow(boxX + boxW, inputY, outXStart, inputY, INK);
                
                p.pop();
            }

        };

        new p5(sketch);
    </script>
</body>
</html>